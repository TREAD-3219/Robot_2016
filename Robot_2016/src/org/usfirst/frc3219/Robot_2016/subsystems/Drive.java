// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3219.Robot_2016.subsystems;

import edu.wpi.first.wpilibj.CANTalon;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.command.Subsystem;
import org.usfirst.frc3219.Robot_2016.RobotMap;
import Robot_2016.utility.JoystickCurveSet;;// need to create class


/**
 *
 */
public class Drive extends Subsystem {
	private static final double MAX_MOTOR_RPM = 4000;
	private static final double WHEEL_DIAMETER = 4.0;
	public static final double WHEEL_CIRCUMFERENCE = WHEEL_DIAMETER * Math.PI;
	private static final double GEAR_RATIO = 8.45;
	private static final double MAX_WHEEL_RPM = MAX_MOTOR_RPM / GEAR_RATIO;
    public static final double MAX_SPEED_IPM = WHEEL_CIRCUMFERENCE * MAX_WHEEL_RPM;
    public static final double MAX_SPEED_IPS = MAX_SPEED_IPM / 60.0;
    public static final double WHEEL_BASE = 27.75; // distance between wheel centers
    private static final double ROTATION_CIRCLE = Math.PI * WHEEL_BASE;
    private static final double MAX_TURN_RATE = MAX_SPEED_IPS / ROTATION_CIRCLE;
    public static final double MAX_TURN_RATE_DPS = MAX_TURN_RATE * 360.0;
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    CANTalon rightDriveFront = RobotMap.driveRightDriveFront;
    CANTalon rightDriveBack = RobotMap.driveRightDriveBack;
    CANTalon leftDriveFront = RobotMap.driveLeftDriveFront;
    CANTalon leftDriveBack = RobotMap.driveLeftDriveBack;
    RobotDrive driveMotors = RobotMap.driveDriveMotors;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // private double[] powerToSpeedLookup = new double[] { 0.0, 0.0, 1.0, 6.6, 15.0, 25.8, 38.8, 53.5, 68.1, MAX_SPEED_IPS + 68.1 / 2.0, MAX_SPEED_IPS };
    
    // throttle at 0.25, speed 3.2 IPS
    // throttle at 0.3, speed 6.6
    // throttle at 0.4, speed 15 IPS
    // throttle at 0.5, speed 25.8 IPS
    // throttle at 0.6, speed 38.8 IPS
    // throttle at 0.7, speed 53.5 IPS
    // throttle at 0.8, speed 68.1 IPS
    JoystickCurveSet curve = JoystickCurveSet.conservative();
    
    public enum Curve {
    	linear,
    	conservative,
    	aggressive
    };
    
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    // just yer basic drive from the stick forwarder.
    public void driveValues(double forward, double turnRate) {
    	driveMotors.arcadeDrive(forward, turnRate);
    }
    
    public void setSafety(boolean safely) {
    	driveMotors.setSafetyEnabled(safely);
    }
    
    public JoystickCurveSet getCurve() {
    	return curve;
    }
    
    public void setCurve(Curve which) {
    	switch (which) {
    	case linear:
    		curve = JoystickCurveSet.linear();
    		break;
    	case conservative:
    		curve = JoystickCurveSet.conservative();
    		break;
    	case aggressive:
    		curve = JoystickCurveSet.aggressive();
    		break;
    	}
    }
    
    public double speedFromPower(double power) {
    	double result = Math.max(0, 71.882*power*power + 39.665* power - 11.083);
    	return result;
    }
    
    // convert inches per second into +/- 1
    public double powerFromSpeed(double speed) {
    	double magnitude = Math.abs(speed);
    	double power = -0.00003*magnitude*magnitude + 0.0111*magnitude + 0.2176;
    	double fixed = Math.min(1.0, power);
    	return fixed * Math.signum(speed);
    }
    
    // convert degrees per second into +/- 1
    public double powerFromTurnRate(double turnRate) {
    	double fixed = powerFromSpeed(turnRate);
    	return fixed * Math.signum(turnRate);
    }
    
    public void driveSpeed(double forwardSpeed, double turnRate) {
    	double power = powerFromSpeed(forwardSpeed);
    	double turns = turnRate / MAX_TURN_RATE_DPS;
    	driveMotors.drive(power, turns);
    }
    
    public void driveTurn(double turnRate) {
    	double curve = (turnRate / MAX_TURN_RATE_DPS) * 3;
    	driveMotors.drive(curve, 1.0);
    }
    
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
}

