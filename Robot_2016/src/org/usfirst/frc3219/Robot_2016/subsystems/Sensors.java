// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc3219.Robot_2016.subsystems;

import edu.wpi.first.wpilibj.AnalogInput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.I2C;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.PowerDistributionPanel;
import edu.wpi.first.wpilibj.SerialPort.Port;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import frc3219.RobotMap;
import frc3219.commands.SensorWatch;
import frc3219.subsystems.Orientation_UM7.Vec;
import frc3219.utility.UM7Utility;

/**
 *
 */
public class Sensors extends Subsystem implements edu.wpi.first.wpilibj.PIDSource {
	private static final double RADIANS_TO_DEGREES = 180 / Math.PI;
	private static final double TICKS_PER_REVOLUTION = 360.0;
	private static final double DISTANCE_PER_PULSE = Drive.WHEEL_CIRCUMFERENCE
			/ TICKS_PER_REVOLUTION;
	private static final double LEFT_CALIBRATION = -1.0;
	private static final double RIGHT_CALIBRATION = 1.0;
	private static final double LEFT_DISTANCE_PER_PULSE = DISTANCE_PER_PULSE
			* LEFT_CALIBRATION;
	private static final double RIGHT_DISTANCE_PER_PULSE = DISTANCE_PER_PULSE
			* RIGHT_CALIBRATION;

	private static final byte LIDAR_1_ADDR = 0x62;
	private static final byte LIDAR_2_ADDR = 0x62; //does this need to be changed?
	private static final byte LIDAR_READ_START = (byte) 0x8F;
	private static final int START_MEASUREMENT = 0x04;
	private static final int READ_CONTROL_REGISTER = 0x00;

	PowerDistributionPanel pdp = new PowerDistributionPanel();
	I2C lidar1 = new I2C(I2C.Port.kMXP, LIDAR_1_ADDR);
	I2C lidar2 = new I2C(I2C.Port.kMXP, LIDAR_2_ADDR); //this might also need to be fixed, idk
	double lastLidar1Read = 0.0;
	double lastLidar2Read = 0.0;
	private Orientation_UM7 um7 = null;
	private Um7Reader um7ReadThread = null;
	private int totalPackets = 0;

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	Encoder rightEncoder = RobotMap.sensorsRightEncoder;
	Encoder leftEncoder = RobotMap.sensorsLeftEncoder;
	AnalogInput ultrasonic1 = RobotMap.sensorsUltrasonic1;
	AnalogInput ultrasonic2 = RobotMap.sensorsUltrasonic2;
	AnalogInput ultrasonic3 = RobotMap.sensorsUltrasonic3;
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	EncoderData rightData = new EncoderData(rightEncoder);
	EncoderData leftData = new EncoderData(leftEncoder);
	AnalogInput ultrasonic4 = RobotMap.sensorsUltrasonic4;
	private double maxTheta = 0.0;
	private PIDInputs pidInput;

	public Sensors() {
		pidInput = PIDInputs.encoderTheta;
	}

	public void initialize() {
		leftEncoder.setDistancePerPulse(LEFT_DISTANCE_PER_PULSE);
		rightEncoder.setDistancePerPulse(RIGHT_DISTANCE_PER_PULSE);
		um7 = new Orientation_UM7(Port.kMXP);
		startLidarMeasurement();
		um7ReadThread = new Um7Reader(um7);
		um7ReadThread.start();
	}

	public int um7PacketsRead() {
		return um7ReadThread.packetsRead();
	}

	public void sensorReset() {
		leftEncoder.reset();
		rightEncoder.reset();
		leftData.reset();
		rightData.reset();
		um7.resetData();
		um7.resetErrors();
		this.maxTheta = 0.0;
		this.lastLidar1Read = 0.0;
		this.lastLidar2Read = 0.0;
	}

	private void startLidarMeasurement() {
		boolean res = lidar1.write(READ_CONTROL_REGISTER, START_MEASUREMENT);
		SmartDashboard.putBoolean("Start Lidar", res);
	}

	public double readLidar1() {
		byte[] bytes = new byte[2];
		double res = -1.0;
		// read the data from the last measure command
		if (lidar1.read(LIDAR_READ_START, 2, bytes)) {
			int cms = UM7Utility.getShort(bytes, 0);
			res = cms / 2.54;
			if (res != 0) {
				lastLidar1Read = res;
			} else {
				res = lastLidar1Read;
			}
			startLidarMeasurement();
		}

		return res;
	}
	
	public double readLidar2() {
		byte[] bytes = new byte[2];
		double res = -1.0;
		// read the data from the last measure command
		if (lidar2.read(LIDAR_READ_START, 2, bytes)) {
			int cms = UM7Utility.getShort(bytes, 0);
			res = cms / 2.54;
			if (res != 0) {
				lastLidar2Read = res;
			} else {
				res = lastLidar2Read;
			}
			startLidarMeasurement();
		}

		return res;
	}

	public int leftEncoderRaw() {
		return leftEncoder.getRaw() / leftEncoder.getEncodingScale();
	}

	public int rightEncoderRaw() {
		return rightEncoder.getRaw() / rightEncoder.getEncodingScale();
	}

	public double leftEncoderDistance() {
		double res = leftEncoder.getDistance();
		return res;
	}

	public double rightEncoderDistance() {
		double res = rightEncoder.getDistance();
		return res;
	}

	public double leftEncoderSpeed() {
		double res = leftEncoder.getRate();
		return res;
	}

	public double rightEncoderSpeed() {
		double res = rightEncoder.getRate();
		return res;
	}

	public double getDistance() {
		return (leftEncoderDistance() + rightEncoderDistance()) / 2.0;
	}

	public double getVelocity() {
		return (leftEncoderSpeed() + rightEncoderSpeed()) / 2.0;
	}

	public void thetaReset() {
		leftData.reset();
		rightData.reset();
	}

	public double getTheta() {
		double lRDelta = leftData.getDeltaDistance() - rightData.getDeltaDistance();
		double theta = lRDelta / Drive.WHEEL_BASE;
		double finalTheta = theta * Sensors.RADIANS_TO_DEGREES;
		maxTheta = Math.max(maxTheta, Math.abs(finalTheta));
		return finalTheta % 360.0;
	}

	public double getThetaDot() {
		double lRDelta = leftData.getDeltaVelocity()
				- rightData.getDeltaVelocity();
		double theta = lRDelta / Drive.WHEEL_BASE;
		return theta * Sensors.RADIANS_TO_DEGREES;
	}

	public double getMaxTheta() {
		return maxTheta;
	}

	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
		setDefaultCommand(new SensorWatch());

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	}

	public double getVoltage() {
		return pdp.getVoltage();
	}

	public double getCurrent() {
		return pdp.getTotalCurrent();
	}

	public double getLeftMotorCurrent() {
		return pdp.getCurrent(0);
	}

	public double getRightMotorCurrent() {
		return pdp.getCurrent(3);
	}

	public double getPower() {
		return pdp.getTotalPower();
	}

	public double getEnergyUsed() {
		return pdp.getTotalEnergy();
	}

	public double getPDPTemperature() {
		return pdp.getTemperature();
	}

	public double getEulerYaw() {
		return this.um7.getEulerAttitude().getZ();
	}

	public Vec getAttitude() {
		return this.um7.getEulerAttitude();
	}

	public double getCompass() {
		return this.um7.getMagnetometer().getZ();
	}

	public Vec getAccel() {
		return this.um7.getAccelerations();
	}

	public Vec getMagnetometer() {
		return this.um7.getMagnetometer();
	}

	public Orientation_UM7 um7() {
		return this.um7;
	}

	private class EncoderData {
		Encoder _myEncoder;
		double _baseDistance;
		double _baseVelocity;

		public EncoderData(Encoder e) {
			_myEncoder = e;
			this.reset();
		}

		public void reset() {
			_baseDistance = _myEncoder.getDistance();
			_baseVelocity = _myEncoder.getRate();
		}

		public double getDeltaDistance() {
			double deltaD = _myEncoder.getDistance() - _baseDistance;
			return deltaD;
		}

		public double getDeltaVelocity() {
			double deltaV = _myEncoder.getRate() - _baseVelocity;
			return deltaV;
		}
	}

	private class Um7Reader extends Thread {
		private boolean keepRunning = true;
		Orientation_UM7 um7 = null;
		int exceptionsCaught = 0;
		private int nullPtrExceptions;

		public Um7Reader(Orientation_UM7 u) {
			um7 = u;
		}

		public int packetsRead() {
			return totalPackets;
		}

		public void run() {
			while (keepRunning) {
				try {
					totalPackets += um7.readPeriodic();
				} catch (NullPointerException ne) {
					System.out.println("null ptr exception");
					exceptionsCaught += 1;
					nullPtrExceptions += 1;
				} catch (Exception e) {
					System.out.println(e.getMessage());
					exceptionsCaught += 1;
				}
				SmartDashboard.putNumber("Reader Exceptions Caught",
						exceptionsCaught);
				SmartDashboard.putNumber("Null Ptr Exceptions",
						nullPtrExceptions);
				SmartDashboard.putNumber("UM7 exceptions caught",
						um7.exceptionsCaught);
				try {
					sleep(50);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}

			System.out.println("shutdown reader thread");
		}
	}

	public void selectPIDInput(PIDInputs in) {
		pidInput = in;
	}

	@Override
	public double pidGet() {
		switch (pidInput) {
		case encoderPosition:
			return getDistance();
		case encoderVelocity:
			return getVelocity();
		case encoderTheta:
			return getTheta();
		case encoderThetaDot:
			return getThetaDot();
		case lidarDistance:
			return readLidar1();
		case lidarVelocity:
			return 0.0;
		case ultrasonic1Distance:
			break;
		case ultrasonic2Distance:
			break;
		case ultrasonic3Distance:
			break;
		case ultrasonic4Distance:
			break;
		case uM7Velocity:
			break;
		case uM7Theta:
			break;
		case uM7ThetaDot:
			break;
		case uM7Phi:
			break;
		case uM7PhiDot:
			break;
		case uM7Psi:
			return getEulerYaw();
		case uM7PsiDot:
			break;
			default:
				break;
		}
		
		return 0.0;
	}

	@Override
	public PIDSourceType getPIDSourceType() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void setPIDSourceType(PIDSourceType arg0) {
		// TODO Auto-generated method stub
		
	};
}
