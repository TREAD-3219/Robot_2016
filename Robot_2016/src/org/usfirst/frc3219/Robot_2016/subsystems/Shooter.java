// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc3219.Robot_2016.subsystems;

import java.awt.Point;

import org.usfirst.frc3219.Robot_2016.Robot;
import org.usfirst.frc3219.Robot_2016.RobotMap;

import edu.wpi.first.wpilibj.CANTalon;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class Shooter extends Subsystem {

	public static final double BOTTOM_SHOOTER_SPEED = 1.0;
	public static final double TOP_SHOOTER_SPEED = 0.7;
	private static final double SHOOTER_STOP_SPEED = 0.0;
	private static final int COUNTER_SAMPLES_TO_AVERAGE = 10;
	private static final double COUNTER_MAX_PERIOD = 0.1;
	private static final int COUNTER_DISTANCE_PER_PULSE = 12;
	public static final String TOPSHOOTER = "ShooterTop";
	public static final String BOTTOMSHOOTER = "ShooterBottom";

	CANTalon shooterTopMotor = RobotMap.driveTopShooter;
	CANTalon shooterBottomMotor = RobotMap.driveBottomShooter;
	
	//public double findXPoint() { //YPoint is always 8'1", or 97"
		//double lidar = Robot.sensors.readLidar1();
		//double x = lidar + 5.55079;
		//return x;
	//}
	
	public double findMotorSpeed(double v) { //gets the speed the motor has to shoot to hit a certain point
		double motorSpeed = 1.0; //velocity times speed/velocity ratio
		return motorSpeed;
	}
	
	public double findVelocityForPoint(double x, double y) {
		double v;
		double g = 386.088583;
		double theta = 45 * (Math.PI / 180);
		v = Math.sqrt(((g * x * x) * (Math.pow(Math.tan(theta), 2) + 1)) / (2 * (Math.tan(theta) * x - y)));
		return v;
	}

	public void init() {
		shooterTopMotor.setSafetyEnabled(false);
		shooterBottomMotor.setSafetyEnabled(false);
		shooterTopMotor.enableBrakeMode(false);
		shooterBottomMotor.enableBrakeMode(false);
		shooterBottomMotor.setInverted(false);

		// set up counter mode
		RobotMap.shooterCounter.setUpDownCounterMode();

		// Reset
		RobotMap.shooterCounter.reset();

		// Counter Setting
		RobotMap.shooterCounter.setMaxPeriod(COUNTER_MAX_PERIOD);
		RobotMap.shooterCounter.setUpdateWhenEmpty(true);
		RobotMap.shooterCounter.setReverseDirection(false);
		RobotMap.shooterCounter.setSamplesToAverage(COUNTER_SAMPLES_TO_AVERAGE);
		RobotMap.shooterCounter.setDistancePerPulse(COUNTER_DISTANCE_PER_PULSE);
		
		SmartDashboard.putNumber(TOPSHOOTER, TOP_SHOOTER_SPEED);
		SmartDashboard.putNumber(BOTTOMSHOOTER, BOTTOM_SHOOTER_SPEED);
	}

	public void spinUp(double TopPower, double BottomPower) {
		this.shooterTopMotor.set(TopPower);
		this.shooterBottomMotor.set(BottomPower * -1);
	}

	public void spinDown() {
		this.shooterTopMotor.set(SHOOTER_STOP_SPEED);
		this.shooterBottomMotor.set(SHOOTER_STOP_SPEED);
	}

	public void initDefaultCommand() {
	}

	public boolean atSpeed() {
		// TODO Auto-generated method stub
		return false;
		
	}
}
