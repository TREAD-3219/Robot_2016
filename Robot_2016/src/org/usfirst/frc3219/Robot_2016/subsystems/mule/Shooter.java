// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc3219.Robot_2016.subsystems.mule;

import org.usfirst.frc3219.Robot_2016.RobotMap;

import edu.wpi.first.wpilibj.Counter;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class Shooter extends Subsystem {

	private static final String SHOOTER_MOTORS_TAG = "Shooter Motors";
	public static final double BOTTOM_SHOOTER_SPEED = 1.0;
	public static final double TOP_SHOOTER_SPEED = 0.7;
	private static final double SHOOTER_STOP_SPEED = 0.0;
	private static final int COUNTER_SAMPLES_TO_AVERAGE = 3;
	private static final double COUNTER_MAX_PERIOD = 0.1;
	private static final int COUNTER_DISTANCE_PER_PULSE = 1;
	public static final String TOPSHOOTER = "ShooterTop";
	public static final String BOTTOMSHOOTER = "ShooterBottom";
	private static final double SHOOTER_RPS_MINIMUM = 10; // 600 RPM - adjust this!
	
	
	public static void setupRobotMap() {
		RobotMap.shooterCounter = new Counter(8);
	}
	
	public Shooter() {
	}

	//public double findXPoint() { //YPoint is always 8'1", or 97"
		//double lidar = Robot.sensors.readLidar1();
		//double x = lidar + 5.55079;
		//return x;
	//}
	
	public double findMotorSpeed(double v) { //gets the speed the motor has to shoot to hit a certain point
		double motorSpeed = 1.0; //velocity times speed/velocity ratio
		return motorSpeed;
	}
	
	public double findVelocityForPoint(double x, double y) {
		double v;
		double g = 386.088583;
		double theta = 45 * (Math.PI / 180);
		v = Math.sqrt(((g * x * x) * (Math.pow(Math.tan(theta), 2) + 1)) / (2 * (Math.tan(theta) * x - y)));
		return v;
	}

	public void init() {
		// set up counter mode
		RobotMap.shooterCounter.setUpDownCounterMode();

		// Reset
		RobotMap.shooterCounter.reset();

		// Counter Setting
		RobotMap.shooterCounter.setMaxPeriod(COUNTER_MAX_PERIOD);
		RobotMap.shooterCounter.setUpdateWhenEmpty(true);
		RobotMap.shooterCounter.setReverseDirection(false);
		RobotMap.shooterCounter.setSamplesToAverage(COUNTER_SAMPLES_TO_AVERAGE);
		RobotMap.shooterCounter.setDistancePerPulse(COUNTER_DISTANCE_PER_PULSE);
		
		SmartDashboard.putNumber(TOPSHOOTER, TOP_SHOOTER_SPEED);
		SmartDashboard.putNumber(BOTTOMSHOOTER, BOTTOM_SHOOTER_SPEED);
	}

	public void spinUp(double TopPower, double BottomPower) {
		SmartDashboard.putBoolean(SHOOTER_MOTORS_TAG, true);
	}

	public void spinDown() {
		SmartDashboard.putBoolean(SHOOTER_MOTORS_TAG, false);
	}

	public void initDefaultCommand() {
	}

	public boolean atSpeed() {
		return SmartDashboard.getBoolean(SHOOTER_MOTORS_TAG, false);
	}
}
